---
layout: post
title: "Bizness"
date: 2024-10-14 10:00:00
categories: writeups
tags: [Linux, CVE enumeration, password hunting, python scripting, cracking hashes]
lang: en
image: /assets/images/bizness/bizness_box.webp
---

![]({{ "/assets/images/bizness/bizness_card.webp" | relative_url }})

# Concepts seen on the machine
```
- CVE-2023-49070 RCE en OFBiz
- Credential hunting
- Creating a script to crack hash SHA1
```

# Enumeration & Initial Foothold

>ðŸ“IP
>```
>10.10.11.252
>```

>ðŸ” Users:Passwords
```
root:monkeybizness
```

>ðŸªª Domains
```
bizness.htb
```
## ðŸ”Ž nmap scanning

We run nmap to see which ports are open.

```python
nmap -p- -sS -Pn -n -vvv --min-rate 3000 -oG all-Ports 10.10.11.252
```

```
nmap --top-ports=300 -sU -vvv -oG UDP-Ports 10.10.11.252
```

```
nmap -p -sCV -vvv -oN Targeted 10.10.11.252
```

![]({{ "/assets/images/bizness/Pasted image 20241014132140.webp" | relative_url }})

We see ports 22, 80, 443, and 40789 open. Let's run nmap again to see the version and service of the processes running on these ports.

![]({{ "/assets/images/bizness/Pasted image 20241014132147.webp" | relative_url }})

From the nmap capture, we see that a redirection is made to the domain `bizness.htb`, so we add it to `/etc/hosts`.

![]({{ "/assets/images/bizness/Pasted image 20241014132159.webp" | relative_url }})

## 80 - HTTP

We launched WhatWeb to learn more about web services.

![]({{ "/assets/images/bizness/Pasted image 20241014132205.webp" | relative_url }})

Let's take a look at the website at the browser level to see what it contains. This is the information on the technologies in use according to Wappalyzer:

![]({{ "/assets/images/bizness/Pasted image 20241014132210.webp" | relative_url }})

After examining the website's source code, we did not find any comments left by the developers. We will launch a route fuzz with Gobuster.

![]({{ "/assets/images/bizness/Pasted image 20241014132215.webp" | relative_url }})

We observe a directory called `/control`. Let's see what this directory contains.

![]({{ "/assets/images/bizness/Pasted image 20241014132222.webp" | relative_url }})

We observe that Apache OFBiz is in use, so we will look for any vulnerabilities that may apply to this application.

After continuing to list paths, we find the path `/webtools/control/main`, where we obtain that the OFBiz version is 18.12.

![]({{ "/assets/images/bizness/Pasted image 20241014132229.webp" | relative_url }})
![]({{ "/assets/images/bizness/Pasted image 20241014132234.webp" | relative_url }})

We searched for public exploits for this version and found one that combines authentication bypass with remote command execution (CVE-2023-49070 and CVE-2023-51467). We downloaded the exploit and will try to see if we can execute commands at the system level.

[exploit](https://github.com/abdoghazy2015/ofbiz-CVE-2023-49070-RCE-POC)

*Please note that since I did the CTF until I published this, the exploit has changed.*

First, we verify that the application is vulnerable to this CVE.

![]({{ "/assets/images/bizness/Pasted image 20241014132631.webp" | relative_url }})

In order to use the exploit, we must download ysoserial. We do this with the following command:

```
wget https://github.com/frohoff/ysoserial/releases/latest/download/ysoserial-all.jar
```

We tried sending a curl to see if commands are actually being executed and received a connection.

![]({{ "/assets/images/bizness/Pasted image 20241014132636.webp" | relative_url }})

We will listen on port 1234 with netcat and send ourselves a reverse shell.

![]({{ "/assets/images/bizness/Pasted image 20241014132648.webp" | relative_url }})
![]({{ "/assets/images/bizness/Pasted image 20241014132653.webp" | relative_url }})

We have access to the victim machine and can see the user flag.

![]({{ "/assets/images/bizness/Pasted image 20241014132706.webp" | relative_url }})

# Privesc

Now we have to find a way to escalate privileges. First, we look for files with SUID permissions, but we don't see any that catch our attention.

![]({{ "/assets/images/bizness/Pasted image 20241014132745.webp" | relative_url }})

We search for cron tasks in the crontab file to see if something is running every x amount of time.

![]({{ "/assets/images/bizness/Pasted image 20241014132750.webp" | relative_url }})

We run linpeas to scan the machine and detect privilege escalation vectors, and we see that we have write permissions on an executable, but it does not run with elevated permissions.

![]({{ "/assets/images/bizness/Pasted image 20241014132759.webp" | relative_url }})

We will launch pspy to see if there are any processes running that are executing root, such as restarting the service or something similar. However, after running pspy, we do not see anything.

Let us see which ports are open within the machine.

```
ss -tulpn
```

![]({{ "/assets/images/bizness/Pasted image 20241014132810.webp" | relative_url }})

Listing the machine, we find a directory `/opt/ofbiz/framework` We find a file with information, but we need the SHA value, so we have to search for it

![]({{ "/assets/images/bizness/Pasted image 20241014132857.webp" | relative_url }})

For each directory in the path, there are files with different hashes.

To search all the files, we will perform a find on the directory that contains them. For each file, we will perform a cat and store it in the file `dir.txt`.

```
find seg0 -type f -exec cat {} \; > dir.txt
```

We read the readable strings with strings because they are binary, we grep for some of the algorithms we have seen.

![]({{ "/assets/images/bizness/Pasted image 20241014133409.webp" | relative_url }})

We found a hash for a user named `admin`, and it is a SHA, which is one of the most insecure hash algorithms, so we will try to crack it with a script. The script is as follows:


```python
import hashlib
import base64
import os

def ciphered(salt, value):
    salt = salt or base64.urlsafe_b64encode(os.urandom(16)).decode('utf-8')
    hashed_bytes = hashlib.sha1((salt + value).encode('utf-8')).digest()
    result = f"$SHA1${salt}${base64.urlsafe_b64encode(hashed_bytes).decode('utf-8').replace('+', '.')}"
    return result
search = input("Enter the hash: ")
wordlist_path = input("Path to the wordlist: ")
salt = "d"
with open(wordlist_path, 'r', encoding='latin-1') as password_list:
    for password in map(str.strip, password_list):
        hashed_password = ciphered(salt, password)
        if hashed_password == search:
            print(f'Found Password: {password}, hash: {hashed_password}')
```

We run the script and obtain the password.

![]({{ "/assets/images/bizness/Pasted image 20241014133431.webp" | relative_url }})

This password was for the user `admin`, but it is possible that it is being reused for the user `root` on the machine. We test it and see that we have gained access and can see the second flag.

![]({{ "/assets/images/bizness/Pasted image 20241014133437.webp" | relative_url }})



